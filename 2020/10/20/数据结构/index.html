<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="舒克">





<title>数据结构 | James&#39;s blog</title>



    <link rel="icon" href="/public/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="James's blog" type="application/atom+xml">
</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Shuker&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Shuker&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">数据结构</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">舒克</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 20, 2020&nbsp;&nbsp;15:24:20</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Program/">Program</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>==version 1.1==</p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>程序设计的实质：数据表示（存储在内存中，核心：数据结构）和数据处理（核心：算法）</p>
<p>数值问题 -&gt; 数学问题</p>
<p>非数值问题 -&gt; 数据结构</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数据：信息的载体"><a href="#数据：信息的载体" class="headerlink" title="数据：信息的载体"></a>数据：信息的载体</h3><p>数据元素：数据的基本单位（讨论数据结构时涉及的最小数据单位）</p>
<p>数据项：构成数据元素的不可分割的最小单位</p>
<h3 id="数据结构：相互之间存在一定关系的数据元素的集合"><a href="#数据结构：相互之间存在一定关系的数据元素的集合" class="headerlink" title="数据结构：相互之间存在一定关系的数据元素的集合"></a>数据结构：相互之间存在一定关系的数据元素的集合</h3><h4 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h4><p>面向问题</p>
<p>是数据元素之间逻辑关系的整体</p>
<p>用来反映数据元素之间的关联方式或邻接关系</p>
<table>
<thead>
<tr>
<th>抽象的数据模型</th>
<th>逻辑关系</th>
</tr>
</thead>
<tbody><tr>
<td>线性表</td>
<td>一对一</td>
</tr>
<tr>
<td>树</td>
<td>一对多</td>
</tr>
<tr>
<td>图</td>
<td>多对多</td>
</tr>
<tr>
<td>集合</td>
<td>除了同属一个集合外没有任何关系</td>
</tr>
</tbody></table>
<h4 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h4><p>面向计算机</p>
<p>用来存储数据元素并显示或隐式地存储数据元素之间的逻辑关系</p>
<p>顺序存储：由元素的存储位置表示逻辑关系</p>
<p>链式存储：用指针表示逻辑关系</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>是对特定问题求解步骤的一种描述，是指令的有限序列</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>输入：可以没有</p>
<p>输出：必须有</p>
<p>有穷性：有穷步在有穷时间内完成</p>
<p>确定性：每条指令有确切含义</p>
<p>可行性：通过已经实现的基本操作执行有限次来实现</p>
<h3 id="好算法"><a href="#好算法" class="headerlink" title="好算法"></a>好算法</h3><p>正确性：合法输入得到正确结果</p>
<p>鲁棒性：对非法输入的抵抗能力</p>
<p>简单性：容易理解和实现</p>
<p>抽象分级：每个逻辑步骤能模块调用</p>
<p>高效性：时、空效率高</p>
<h3 id="描述方法"><a href="#描述方法" class="headerlink" title="描述方法"></a>描述方法</h3><table>
<thead>
<tr>
<th>语言</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>自然语言</td>
<td>容易理解</td>
<td>有二义性</td>
</tr>
<tr>
<td>流程图</td>
<td>直观易懂</td>
<td>严密性不如程序语言，灵活性不如自然语言</td>
</tr>
<tr>
<td>程序设计语言</td>
<td>能直接执行</td>
<td>抽象性差，拘于细节</td>
</tr>
<tr>
<td>伪代码</td>
<td>算法语言</td>
<td>真没缺点</td>
</tr>
</tbody></table>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>事后统计</p>
<p>事前分析估算：渐进复杂度</p>
<h3 id="问题规模"><a href="#问题规模" class="headerlink" title="问题规模"></a>问题规模</h3><p>输入量的多少（n）</p>
<p>Eg：找到100以内的素数，问题规模为100</p>
<p>基本语句：执行次数与整个算法的执行次数成正比的语句</p>
<h3 id="渐进时间复杂度-O-n-P15"><a href="#渐进时间复杂度-O-n-P15" class="headerlink" title="渐进时间复杂度 O(n)    P15"></a>渐进时间复杂度 O(n)    P15</h3><p>平均情况：假设数据等概率分布</p>
<p>O(log[2] n)&lt;O(n)&lt;O(n*log[2] n)&lt;O(n^2)</p>
<p>Eg：</p>
<p>1、三层循环 O(n^3)</p>
<p>2、for(int i=1;i&lt;=n;i=2*i)</p>
<p>​            x++;</p>
<p>2^(T(n))&lt;=n </p>
<p>T(n)&lt;=log[2] n</p>
<p>3、for(int i=1;i&lt;=n;i++)</p>
<p>​            for(int j=1;j&lt;=i-1;j++)</p>
<p>​                x++;</p>
<p>求和（i-1）= n(n-1)/2</p>
<h1 id="线性表-L-a1-…-an"><a href="#线性表-L-a1-…-an" class="headerlink" title="线性表 L=(a1, …, an)"></a>线性表 L=(a1, …, an)</h1><p>长度：线性表的长度（有限序列）</p>
<p>空表 L=( )：长度为0</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>InitList</p>
<p>DestroyList</p>
<p>Length</p>
<p>Get 按位查找</p>
<p>Locate 按值查找</p>
<p>Insert</p>
<p>Delete</p>
<p>Empty</p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>有限性：数据元素个数有穷</p>
<p>向同性：元素类型统一</p>
<p>顺序性：存在序偶关系，每个元素有且仅有一个前驱后继</p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>用地址连续的存储单元依次存储线性表的数据元素，通常用一维数组实现</p>
<p>静态存储分布</p>
<p>基地址：起始地址</p>
<p>数组长度 &gt;= 线性表长度</p>
<p>存取结构：<strong><em>随机存取</em></strong></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>无需为表示元素间的逻辑关系新增空间</p>
<p>随机存取可以快速存取任意位置元素</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>插入删除需要移动大量元素</p>
<p>表容量难确定，难扩充</p>
<p>造成存储空间碎片</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表只有一个指针域</p>
<p>存储特点：</p>
<p>逻辑次序和物理次序不一定相同</p>
<p>元素之间的逻辑关系用指针表示</p>
<p>存取结构：<strong><em>顺序存取</em></strong></p>
<h3 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h3><p>数据元素的存储映像</p>
<p>头结点：第一个元素结点之前附设的结点，以便空表和非空表处理统一</p>
<p>首结点：</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>存储的后继元素的地址信息</p>
<p>头指针：指向第一个元素所在的结点，起标识一个单链表的作用</p>
<p>尾标志：最后一个元素所在的终端结点的指针域为NULL</p>
<h3 id="其他链表"><a href="#其他链表" class="headerlink" title="其他链表"></a>其他链表</h3><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>附设头结点，空表和非空表处理一致</p>
<p>没有明显尾端（P != first）</p>
<p>开始结点：first-&gt;next</p>
<p>带尾指针时</p>
<p>开始结点：rear-&gt;next-&gt;next</p>
<p>终端结点：rear</p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>快速求直接前驱</p>
<p>空间换时间</p>
<h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>间接寻址：结合数组和指针，将数组中存储数据元素的单元改为存储指向该元素的指针</p>
<p>优点：插入删除时只需要修改指针不移动元素</p>
<p>缺点：没解决连续存储分配的问题，还需要维护一个空闲链，不能随机存取</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h3><p>实现基于某存储结构的基本操作的时间复杂度</p>
<h3 id="空间性能"><a href="#空间性能" class="headerlink" title="空间性能"></a>空间性能</h3><p>存储密度 = 数据域占用的存储量 / 整个结点占用的</p>
<p>顺序表 = 1 存储空间利用率较高                                                                                                                                                                                                                                                                                                                               </p>
<p>链表 &lt; 1</p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>操作受限的线性表，逻辑结构相同</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>限定仅在表尾插入删除的线性表，单一的前驱和后继</p>
<p>特性：后进先出</p>
<p>栈顶：允许插入和删除</p>
<p>栈空：不含任何数据元素的栈</p>
<h3 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h3><p>Push</p>
<p>Pop</p>
<p>GetTop</p>
<p>Empty</p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>栈空：top = -1</p>
<p>栈满：top = StackSize - 1</p>
<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>栈空：top1 = - 1        top2 = Stack_Size</p>
<p>栈满：top2 = top1 + 1        top1 = top2 - 1</p>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>以单链表的头部做栈顶，不需要附设头结点</p>
<p>头插入栈</p>
<h3 id="顺序栈vs链栈"><a href="#顺序栈vs链栈" class="headerlink" title="顺序栈vs链栈"></a>顺序栈vs链栈</h3><p>基本操作的算法只需要常数时间</p>
<p>链栈有结构性开销，应采用顺序栈</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>只允许在一端插入另一端删除的线性表</p>
<p>特性：先进先出</p>
<p>队尾：允许出队（删除）</p>
<p>设置队头、队尾两个指针，改进出队时间性能 </p>
<p>队头指针：头元素前一个位置</p>
<p>队尾指针：队尾元素</p>
<h3 id="ADT-1"><a href="#ADT-1" class="headerlink" title="ADT"></a>ADT</h3><p>EnQueue</p>
<p>DeQueue</p>
<p>GetQueue</p>
<p>Empty</p>
<h3 id="顺序存储-循环队列"><a href="#顺序存储-循环队列" class="headerlink" title="顺序存储-循环队列"></a>顺序存储-循环队列</h3><p>假溢出：元素插入数组下标较大的位置移过去，数组的低端还有空闲空间</p>
<p>队空：front = rear = QueueSize - 1</p>
<p>队满：( rear + 1 ) % QueueSize = front</p>
<p>（头尾）进一：rear = ( rear + 1 ) % QueueSize</p>
<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>使用头结点，使操作统一</p>
<h1 id="字符串和多维数组-S-“s1-s2-…-sn”"><a href="#字符串和多维数组-S-“s1-s2-…-sn”" class="headerlink" title="字符串和多维数组 S=“s1 s2 … sn”"></a>字符串和多维数组 S=“s1 s2 … sn”</h1><p>是数据元素为单个字符的线性表</p>
<p>串：零个或多个字符组成的有限序列<br>空格串：包含空格的串<br>子串：任意个连续的字符组成的子序列<br>主串：包含子串的串<br>子串在主串中的位置：子串的第一个字符在主串中的序号<br>字符串的比较：由ASCII码决定</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>在主串S中寻找子串T的过程<br>模式：子串T</p>
<h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><p>主串每一个分别与子串每一个比较</p>
<p>最好情况下时间复杂度O(n+m)<br>改进的KMP算法：<br>i不回溯，j回溯到next[j]<br>失败时 T[0]<del>T[k-1]=S[i-k]</del>S[i-1]<br>成功时 T[j-k]<del>T[j-1]=S[i-k]</del>S[i-1]<br>综上 T[0]<del>T[k-1]=T[j-k]</del>T[j-1]</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>类型相同的数据元素构成的有序集合<br>行[l1,h1]、列[l2,h2]：loc=基地址+c((i-l1)(h2-l2+1)+(j-l2))</p>
<h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p>行优先：以行序为主序<br>特殊矩阵：很多值相同的元素且他们的分布有规律，<em>稀疏矩阵不属于特殊矩阵</em><br>压缩存储：值相同的元素只分配一个存储空间，零元素不分配存储空间</p>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>关于主对角线对称，只存储下三角部分（和主对角线）<br>n*n -&gt; n(n+1)/2<br>存在数组SA[n(n+1)/2]中，下标k=i(i-1)/2+j-1（下标从0开始）</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p>对称矩阵，对角线上为常数c<br>n*n -&gt; n(n+1)/2+1<br>存在数组SA[n(n+1)/2+1]中，下标为k（从0开始）</p>
<h5 id="下三角"><a href="#下三角" class="headerlink" title="下三角"></a>下三角</h5><p>当 i &gt;= j 时 k = i(i-1)/2+j-1<br>当 i &lt; j 时 k = n(n+1)/2</p>
<h5 id="上三角"><a href="#上三角" class="headerlink" title="上三角"></a>上三角</h5><p>当 i &lt;= j 时 k = (i-1)(2n-i+2)/2+j-i<br>当 i &gt; j 时 k = n(n+1)/2</p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p>k = 2 + 3(i-2) + (j-i+2)</p>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>非零元素分布没有规律</p>
<p>三元组顺序表<br>row，col，item<br>在顺序表倒数三行需要存矩阵的行、列数、非零元的个数<br>十字链表<br>row，col，item，right，down<br>right 同行下一个三元组<br>down 同列下一个三元组</p>
<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h2><p>树：n&gt;=0个结点的有限集合</p>
<p>空树：n=0</p>
<p>非空树：有且仅有一个根节点，其余结点分为m个互不相交的集合，每个集合都是这个根节点的一棵子树</p>
<p>结点：数据元素</p>
<p>度：子树的个数为结点的度，各节点的最大值为该树的度</p>
<p>叶子结点（终端结点）：度为0的结点</p>
<p>分支结点（非终端结点）：度不为0</p>
<p>路径长度：路径上进过的边数，在树中路径是唯一的</p>
<p>结点层数（树的深度、高度）：根结点的层数为1</p>
<p>同层编号：每层从左到右从1开始编号</p>
<p>有序树：从左到右有次序</p>
<p>森林：任何一个数删除根结点就变成森林了，<em>一棵树也可称为森林</em></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>前序：先根后括号</p>
<p>中序：左根右</p>
<p>后序：先左右后根</p>
<p>层序：从第一层，逐层遍历</p>
<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>静态链表（数组）</p>
<p>只存储双亲或带右兄弟的双亲</p>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><h4 id="多重链表表示法"><a href="#多重链表表示法" class="headerlink" title="多重链表表示法"></a>多重链表表示法</h4><p>纯链表，双亲指向孩子</p>
<p>指针域的个数 = 度</p>
<p>缺点：各结点不同构时树的各种操作不容易实现，各结点同构时浪费存储空间</p>
<h4 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h4><p>数组存所有数据</p>
<p>数组中的firstchild用来存链表的表头，链表存结点的孩子</p>
<h4 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a>双亲孩子表示法</h4><p>孩子链表的基础上数组里加上双亲的下角标</p>
<h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>纯链表</p>
<p>左边存第一个孩子，右边存右兄弟</p>
<h2 id="二叉树的逻辑结构"><a href="#二叉树的逻辑结构" class="headerlink" title="二叉树的逻辑结构"></a>二叉树的逻辑结构</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>n &gt;= 0</p>
<p>不存在度大于2的结点</p>
<p><strong><em>是有序的</em></strong>（本书）</p>
<p>斜树：所有结点都只有左子树或右子树，每层只有一个结点</p>
<p><em>满二叉树：叶子结点只出现在下一层，只有度为0和度为2的结点</em></p>
<p><em>完全二叉树：叶子结点只出现在下面俩层，如果有度为1的结点，只能有一个且该结点只有左孩子</em></p>
<p>满二叉树必是完全二叉树</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>1、第i层上最多有$2^{i-1}$个</p>
<p>2、深度为k的二叉树最多有$2^k-1$个结点，最少有k个结点</p>
<p>3、叶子结点个数为$n_0$，度为2的结点个数为$n_2$，则$n_0=n_2+1$</p>
<p>4、具有n个结点的完全二叉树深度为$\lfloor log_2n \rfloor+1$</p>
<p>5、完全二叉树从1开始按层序编号</p>
<p>如果i&gt;1，结点i的双亲编号为$\lfloor i/2 \rfloor$</p>
<p>如果2i&lt;=n，结点i的左孩子编号为2i</p>
<p>如果2i+1&lt;=n，结点i的右孩子编号为2i+1</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>把二叉树按完全二叉树编号，符合性质5</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的逻辑结构"><a href="#图的逻辑结构" class="headerlink" title="图的逻辑结构"></a>图的逻辑结构</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><ol>
<li><p>图：由顶点的有穷<strong>非空</strong>集合和顶点之间边的集合组成（可以无边，必须有点）</p>
</li>
<li><p>无向边：俩顶点$v_i$和$v_j$之间的边没有方向<br>有向边（弧）：$v_i$为弧头，$v_j$为弧尾，用序偶对表示</p>
</li>
<li><p>无向图：任意边都是无向边，否则为有向图</p>
<p>无向完全图：任意两个顶点之间都有边</p>
<p>n个顶点则有n*(n-1)/2条边</p>
<p>有向完全图：任意两个顶点之间都有方向相反的两条弧</p>
<p>n个顶点则有n*(n-1)条边</p>
</li>
</ol>
<h3 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h3><ol>
<li><p>简单图：不存在顶点到自身的边，且同一边不重复出现</p>
</li>
<li><p>邻接：存在弧&lt;vi, vj&gt;，称顶点vi邻接vj，vj邻接自vi；弧&lt;vi, vj&gt;依附于顶点vi和vj；vj是vi的邻接点，vi不是vj的邻接点</p>
</li>
<li><p>稀疏图：边数很少的图，反之为稠密图</p>
</li>
<li><p>顶点的度：依附于该顶点的边的个数，入度+出度<br>入度：以该顶点为弧头的弧的个数<br>出度：以该顶点为弧尾的弧的个数</p>
</li>
<li><p>权：对边赋予的有意义的数值量<br>网：边上带权的图</p>
</li>
<li><p>路径：一个顶点序列（从一个顶点到另一个顶点）<br>路径长度：路径上边的数目（有权的话是权的和）<br>回路（环）：第一个顶点和最后一个顶点相同的路径<br>简单路径：顶点不重复出现的路径<br>简单回路： 除了第一个顶点和最后一个顶点外其余顶点不重复出现的回路（只绕一圈）</p>
</li>
<li><p>子图：一个图的点和边是另一个图的子集</p>
<p>一个图可以有很多子图<br>连通图（无向图）：任意两点之间有路径（不考虑自己到自己）<br>连通分量：非连通图的极大连通子图<br>强连通图：（有向图）两点之间均有路径<br>强连通分量：非强连通图的极大强连通子图</p>
</li>
<li><p>生成树：n个顶点的连通图G的生成树是包含G中全部顶点的一个极小连通子图</p>
<p>森林：每个连通分量得到的生成树构成的非连通图</p>
</li>
</ol>
<h3 id="ADT-2"><a href="#ADT-2" class="headerlink" title="ADT"></a>ADT</h3><p>InitGraph<br>DestroyGraph<br>DFSTraverse<br>BFSTraverse</p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>深度优先（类似树的前序遍历）</p>
<p>广度优先（树的层序遍历）</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>矩阵vertex和顶点表arc<br>图：无边为0，有边为1<br>网：无边为∞，有边为权，主对角线为0</p>
<h3 id="邻接表（出边表）、逆邻接表（入边表）"><a href="#邻接表（出边表）、逆邻接表（入边表）" class="headerlink" title="邻接表（出边表）、逆邻接表（入边表）"></a>邻接表（出边表）、逆邻接表（入边表）</h3><p>顶点表（顺序）VertexNode：存所有顶点权值vertex和firstedge边表第一个结点<br>边表（链式）ArcNode：存顶点下标adjvext和next<br>存下标的原因：顶点可能结构复杂，修改结点的开销大<br>插入用头插，节省时间</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>存储有向图<br>邻接表和逆邻接表的结合</p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>存储无向图表（顺序）<br>边表（链式）：</p>
<table>
<thead>
<tr>
<th>结点域</th>
<th>Statement</th>
</tr>
</thead>
<tbody><tr>
<td>ivex</td>
<td>某边依附顶点的下标i</td>
</tr>
<tr>
<td>ilink</td>
<td>依附于ivex的下一边</td>
</tr>
<tr>
<td>jvex</td>
<td>下标j</td>
</tr>
<tr>
<td>jlink</td>
<td>依附于jvex的下一边</td>
</tr>
</tbody></table>
<h3 id="邻接矩阵和邻接表的比较"><a href="#邻接矩阵和邻接表的比较" class="headerlink" title="邻接矩阵和邻接表的比较"></a>邻接矩阵和邻接表的比较</h3><table>
<thead>
<tr>
<th></th>
<th>空间</th>
<th>时间</th>
<th>适用范围</th>
<th>唯一性</th>
</tr>
</thead>
<tbody><tr>
<td>矩阵</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>稠密图</td>
<td>唯一</td>
</tr>
<tr>
<td>表</td>
<td>O(n+e)</td>
<td>O(n+e)</td>
<td>稀疏图</td>
<td>不唯一</td>
</tr>
</tbody></table>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="MST性质"><a href="#MST性质" class="headerlink" title="MST性质"></a>MST性质</h3><p>一条具有最小权值的边，则必存在一课包含该边的最小生成树</p>
<h3 id="Prim（需代码）"><a href="#Prim（需代码）" class="headerlink" title="Prim（需代码）"></a>Prim（需代码）</h3><p>shortEdge</p>
<p>lowcost</p>
<p>adjvex</p>
<h1 id="查找技术"><a href="#查找技术" class="headerlink" title="查找技术"></a>查找技术</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>1、关键码：可以标识一个记录的某个数据项</p>
<p>关键值：关键码的值</p>
<p>主关键码：唯一标识一个记录，反之次关键码</p>
<p>2、查找：在具有相同类型的记录构成的集合中找到满足给定条件的记录</p>
<p>查找结果：返回查找到的记录的位置或值</p>
<p>静态查找：不涉及插入和删除操作</p>
<p>动态查找：查找不成功时插入数据</p>
<p>3、查找结构：为提高查找效率设计的数据结构</p>
<table>
<thead>
<tr>
<th>查找结构</th>
<th>适用</th>
<th>主要技术</th>
</tr>
</thead>
<tbody><tr>
<td>线性表</td>
<td>静态</td>
<td>顺序查找、折半查找</td>
</tr>
<tr>
<td>树表</td>
<td>动态</td>
<td>二叉排序树</td>
</tr>
<tr>
<td>散列表</td>
<td>都可</td>
<td>散列技术</td>
</tr>
</tbody></table>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>时间性能：关键码的比较次数</p>
<p>T(n,k)：问题规模n中查找位置k</p>
<p>平均查找长度：ASL=$\Sigma pc$ 查找概率乘以比较次数求和</p>
<h2 id="线性表查找"><a href="#线性表查找" class="headerlink" title="线性表查找"></a>线性表查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>待查值放在开头，设置为“哨兵”，从后向前查找，链式结构“哨兵”设置在头节点</p>
<p>表长大于1000时平均时间减半</p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>可利用递归</p>
<p>计算mid，根据比较调整low和high</p>
<p>比较次数为mid计算次数</p>
<h4 id="折半查找判定树（判定树）"><a href="#折半查找判定树（判定树）" class="headerlink" title="折半查找判定树（判定树）"></a>折半查找判定树（判定树）</h4><p>结点记录查找过程结点在表中的位置</p>
<p>性质：</p>
<p>任意两折半查找判定树，若结点相同结构一定相同</p>
<p>任意两个叶子所在层数最多相差一</p>
<h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>技术</th>
<th>要求</th>
<th>缺点</th>
<th>优点</th>
<th>ASL</th>
<th>时间性能</th>
</tr>
</thead>
<tbody><tr>
<td>顺序</td>
<td>无要求</td>
<td>n大时效率低</td>
<td>算法简单 适用面广</td>
<td>$\Sigma p(n-i+1)$</td>
<td>O(n)</td>
</tr>
<tr>
<td>折半</td>
<td>有序 顺序存储</td>
<td>要求高</td>
<td>效率高</td>
<td>$\Sigma(i*s^{i-1})$</td>
<td>O($log_2 n$)</td>
</tr>
</tbody></table>
<p>每个记录查找概率相同时p=1/n</p>
<h2 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h2><h3 id="二叉排序树（查找树）"><a href="#二叉排序树（查找树）" class="headerlink" title="二叉排序树（查找树）"></a>二叉排序树（查找树）</h3><p>构造-&gt;查找-&gt;插入，查找是插入的前序过程</p>
<p>空树 或 左孩子&lt;结点&lt;右孩子</p>
<p>二叉链表</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>舒克</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2020 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/C/"># C++</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/11/13/anaconda/">anaconda</a>
            
            
            <a class="next" rel="next" href="/2020/07/08/%E7%88%AC%E8%99%AB/">爬虫</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 舒克 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
