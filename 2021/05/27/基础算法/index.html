<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>基础算法 | Li Ting</title>

    <meta name="description" content="Li Ting">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="cn" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "基础算法 | Li Ting"  />
    <meta property="og:description" content= "Li Ting" />
    <meta property="og:url" content="https://liting1024.github.io/2021/05/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="李挺" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="Li Ting" />
    <meta name="twitter:title" content="基础算法 | Li Ting"/>
    <meta name="twitter:description" content="Li Ting"/>
    <script type="application/ld+json">
        {
            "description": "Li Ting",
            "author": { "@type": "Person", "name": "李挺" },
            "@type": "BlogPosting",
            "url": "https://liting1024.github.io/2021/05/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "https://liting1024.github.ioundefined"
            },
            "name": "李挺"
            },
            "headline": "基础算法 | Li Ting",
            "datePublished": "2021-05-27T14:43:44.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://liting1024.github.io/2021/05/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    
    <meta property="algolia:search" data-application-id="ISC1J3PZW8" data-api-key="8ca1e8ef1083d2f2d2acee1b617e3850" data-index-name="liting_homepage">
    

    

    

    

    
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1651727875408.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1651727875408.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            gitalk: {
                enable: true,
                clientID: "6d0cedf1b471cbc3fb0d",
                clientSecret: "397c8d7ca7ab800dba9e60fd593649b23b6059b8",
                repo: "comments-section",
                owner: "liting1024",
                admin: ["liting1024",],
                distractionFreeMode: true  // Facebook-like distraction free mode
            },
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Li Ting" type="application/atom+xml">
</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Li Ting</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">首页</a>
                
                <a href="/archives">存档</a>
                
                <a href="/collection">收藏</a>
                
                <a href="/about">关于</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/liting1024">
        <box-icon type='logo' name='github'></box-icon>
    </a>

    <a class="social" target="_blank" href="mailto:jkliting@163.com">
        <box-icon type='solid' name='envelope'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">首页</a>
                    
                    <a href="/archives">存档</a>
                    
                    <a href="/collection">收藏</a>
                    
                    <a href="/about">关于</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clab006s2001b1ovmar5s25jw" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      基础算法
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2021-05-27T14:43:44.000Z" itemprop="datePublished">2021-05-27</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACM/" rel="tag">ACM</a></li></ul>
            </div>
            

            
            <div class="article-busuanzi">
                <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序-分治"><a href="#快速排序-分治" class="headerlink" title="快速排序 - 分治"></a>快速排序 - 分治</h3><p>分治：不断把数据分成两部分，一半小于另一半</p>
<ol>
<li><p>确定分界（4种方法）：取q[l], q[(l + r) / 2], q[r], 随机点 </p>
</li>
<li><p>调整区间：小于分界点的在左区间，其余在右区间 </p>
<p>​    使用两个数组作为左右区间 </p>
<p>​    使用两个指针（i = l - 1，j = r + 1），如果a[i]&gt;x,a[i]&lt;x，交换a[i] a[j] </p>
</li>
<li><p>递归：给左右排序 </p>
</li>
</ol>
<pre><code class="c++">void quick_sort(int q[], int l, int r) {
    if (l &gt;= r) 
      return;

    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];
    while (i &lt; j) {
        do i ++ ; while (q[i] &lt; x);
        do j -- ; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j); quick_sort(q, j + 1, r);
}</code></pre>
<h3 id="归并排序-分治（稳定）"><a href="#归并排序-分治（稳定）" class="headerlink" title="归并排序 - 分治（稳定）"></a>归并排序 - 分治（稳定）</h3><p>合并：两个有序数组</p>
<p>双指针：比较两个数组里待合并的数，将较小的放入新数组</p>
<ol>
<li>确定分界点 mid = (l + r) / 2 数组的中心</li>
<li>递归</li>
<li>归并两个有序数组（用双指针合并）</li>
</ol>
<pre><code class="C++">void merge_sort(int q[], int l, int r) {
    if (l &gt;= r) return;

    int mid = l + r &gt;&gt; 1; // 用mid将原数组一分为二
    // 先递归到底
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= r) 
        // 双指针i和j分别对mid左右的两个数组遍历
        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    // 将剩余的部分加入数组
    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];
    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
}</code></pre>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>有单调性 一定可以 二分</p>
<p>求范围，让答案在收缩的区间里</p>
<p>向左收缩和向右收缩mid的取值不同</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_90b4ffa079-IMG_67CE3ECA2B0B-1.jpeg" alt="IMG_67CE3ECA2B0B-1.jpeg"> </p>
<pre><code class="C++">// 整数二分
bool check(int x) {} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：向左收缩
int bsearch_1(int l, int r) {
    while (l &lt; r) {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    } // 结束时l和r相等
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：向右收缩
int bsearch_2(int l, int r) {
    while (l &lt; r) {
        int mid = l + r + 1 &gt;&gt; 1;//防止死循环 多加1
        if (check(mid)) l = mid; // arr[mid]=x 时需要取边界
        else r = mid - 1;
    }
    return l;
}</code></pre>
<p> 对于浮点数 将while里停止的条件改为 r - l &gt; 1e-6</p>
<p>while控制的精度最好小于输出保留位数两位，防止精度不够</p>
<p>Eg：输出小数点后四位，这里控制为1e-6</p>
<pre><code class="C++">// 实数二分
bool check(double x) {} // 检查x是否满足某种性质

double bsearch_3(double l, double r) {
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}</code></pre>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>用数组存大整数，低地址存低位（小端），0存个位</p>
<h3 id="加"><a href="#加" class="headerlink" title="加"></a>加</h3><pre><code class="C++">// C = A + B, A &gt;= 0, B &gt;= 0
vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) {
    if (A.size() &lt; B.size()) return add(B, A);

    vector&lt;int&gt; C;
    int t = 0;
    for (int i = 0; i &lt; A.size(); i ++ ) {
        t += A[i];
        if (i &lt; B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}</code></pre>
<h3 id="减"><a href="#减" class="headerlink" title="减"></a>减</h3><p>A &lt; B =&gt; -(B - A) </p>
<pre><code class="C++">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0
bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) {
    if (A.size() != B.size()) return A.size() &gt; B.size();
    for (int i = A.size()-1; i &gt;= 0; i--) 
        if (A[i] != B[i]) return A[i] &gt; B[i];
    return true; // 
}
vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { //引用 节省时间
    vector&lt;int&gt; C;
    for (int i = 0, t = 0; i &lt; A.size(); i ++ ) {
        t = A[i] - t;
        if (i &lt; B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
          // 只防止负数 不会改变结果 
        //（1+10）%10 = 1 （10+10）%10 = 0
        if (t &lt; 0) t = 1;
        else t = 0;
    }
        // 去除多个 0
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
}
// 主函数
if (cmp(A, B)) C = sub(A, B);
else {
    C = sub(B, A);
    cout&lt;&lt;&#39;-&#39;;
}</code></pre>
<h3 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h3><pre><code class="C++">// C = A * b, A &gt;= 0, b &gt;= 0
vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b) {
    vector&lt;int&gt; C;

    for (int i = 0, t = 0; i &lt; A.size() || t; i ++ ) {
        if (i &lt; A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();

    return C;
}</code></pre>
<h3 id="除"><a href="#除" class="headerlink" title="除"></a>除</h3><p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_46df52f37a-IMG_CF57C855FBAC-1.jpeg" alt="IMG_CF57C855FBAC-1.jpeg"> </p>
<pre><code class="C++">// A / b = C ... r, A &gt;= 0, b &gt; 0
// 引用直接修改原来的r
vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) {
    vector&lt;int&gt; C;
    r = 0;
    for (int i = A.size() - 1; i &gt;= 0; i -- ) {
        r = r * 10 + A[i]; // 借位
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
}</code></pre>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>应用：计算前缀和</p>
<p>存前缀和的下标从1开始，将数组下标为0的值设为0</p>
<h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_fda86e367a-IMG_D9E1403749B2-1.jpeg" alt="IMG_D9E1403749B2-1.jpeg"></p>
<h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_bfe890657b-96221_82a4b4b87a-IMG_57AF8F31A5F1-1.jpg" alt="96221_82a4b4b87a-IMG_57AF8F31A5F1-1.jpg"> </p>
<pre><code class="C++">// 一维
s[i] = s[i-1] + a[i];
s[j] - s[i-1];

// 二维
sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + a[i][j];
sum[x2][y2] - sum[x2][y1-1] - sum[x1-1][y2] + sum[x1-1][y1-1];</code></pre>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>应用：在[ l , r ]之间的每个数加上 c</p>
<p>前缀和的逆运算</p>
<h3 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h3><p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_2d5a8c7d7b-IMG_C86BC0DC46CD-1.jpeg" alt="IMG_C86BC0DC46CD-1.jpeg"> </p>
<h3 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h3><p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_3c3bcc877b-IMG_66D0BEAAF6CD-1.jpeg" alt="IMG_66D0BEAAF6CD-1.jpeg"> </p>
<pre><code class="C++">// 一维
// a存b的前缀和
b[i] = a[i]-a[i-1]

void insert(int l, int r,int c) {
  b[l] += c;
  b[r+1] -= c;
}
// 求前缀和 得到操作后的a数组
b[i] += b[i-1];

// 二维
void insert(int x1,int y1,int x2,int y2,int c) {
    b[x1][y1] += c;
    b[x2+1][y1] -= c;
    b[x1][y2+1] -= c;
    b[x2+1][y2+1] += c;
}
// 求前缀和 把b还原成加了c之后的a
b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];
</code></pre>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>核心：将两个指针 n^2 优化到 n ， 没思路可以先写一个 n^2 找规律</p>
<p>两个序列：合并；归并排序的归并、快速排序的划分；KMP</p>
<p>一个序列：确定区间的开头结尾，如：滑动窗口；判断环</p>
<pre><code class="C++">for (i = 0, j = 0; i &lt; n; i++) {
    while(j &lt; i &amp;&amp; check(i, j)) j++;
}</code></pre>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>n&gt;&gt;k&amp;1：n（二进制）的第k位（从第0位开始）</p>
<p>1&lt;&lt;n：2的n次方</p>
<p>lowbit(x) { return x&amp;-x;}：x&amp;(~x+1)，即返回x的最后一位1，可以计算1的个数</p>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>不进位加法，相同为0，不同为1</p>
<table>
<thead>
<tr>
<th align="center">运算</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0^x = x</td>
<td align="center">0异或还是原数</td>
</tr>
<tr>
<td align="center">1^1010 = 1011</td>
<td align="center">1异或末尾取反</td>
</tr>
<tr>
<td align="center">x^x = 0</td>
<td align="center">异或自己得0</td>
</tr>
<tr>
<td align="center">a^b == 0</td>
<td align="center">判断a和b是否相等</td>
</tr>
</tbody></table>
<p>交换a和b：a = a ^ b, b = b ^ a, a = a ^ b</p>
<p>交换律： a ^ b = b ^a, a ^ b ^ a = b 可以用于找奇数个数的数</p>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>离散化：稀疏数组中，10^5个数，值域为 0 ~ 10^9，将值域映射到 0 ~ n</p>
<p>难点：可能存在重复元素，并能及时得到离散化后的值</p>
<p>应用：稀疏数组即数组下标很大，但数组中很多值是空的</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_3d6388e57c-IMG_DA2CAA82DDB6-1.jpeg" alt="IMG_DA2CAA82DDB6-1.jpeg"> </p>
<pre><code class="C++">// 用vector模拟set，可以用下标访问
vector&lt;int&gt; vec;
sort(vec.begin(), vec.end()); // 排序
vec.erase(unique(vec.begin(), vec.end()), vec.end()); // 去重
// 用二分找第一个大于等于x的，相当于lower_bound()
int find(int x) { 
    int l = 0, r = vec.size()-1;
    while (l &lt; r) {
        int mid = l+r&gt;&gt;1;
        if (vec[mid] &gt;= x) r = mid;
        else l = mid + 1;
    }
    return r+1; // 从1开始映射
}</code></pre>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre><code class="C++">/*
* head 头结点下标 存值
* e 存val
* ne 存next
* idx 表示e中当前位置
*/
int head, e[N], ne[N], idx;
// 头插
void add_to_head(int x) {
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx ++;
}
// 下标为k的后面插x
void add(int k, int x) { 
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx ++;
}
// 删k后的点 (-1后的点为0)
void remove(int k) {
    if (k == -1) head = ne[head];
    ne[k] = ne[ne[k]];
}
void init() {
    head = -1;
    idx = 0;
}</code></pre>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><pre><code class="C++">int head[N];</code></pre>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>优化某些问题</p>
<pre><code class="C++">int head, tail;
int e[N], l[N], r[N], idx;
void init() {
    head = -1; 
    tail = -1;
    idx = 0;
}
// 在k右边插入 
// 在k左边插入 add(l[k], x);
void add(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx ++;
}
void remove(int k) {
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}</code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>应用：找每个数左边第一个比它小/大的数、视野总和、柱状图中最大矩形</p>
<p>有序栈：如果<strong>栈为空</strong>或<strong>入栈元素值小于栈顶元素值</strong>，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。</p>
<p>思想：先考虑暴力，然后优化</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_207657767c-IMG_75854B600D80-1.jpeg" alt="IMG_75854B600D80-1.jpeg"> </p>
<pre><code class="C++">// STL
for (int i = 0; i &lt; n; i ++ ) {
    cin&gt;&gt;x;
    while (!stk.empty() &amp;&amp; stk.top() &gt;= x) stk.pop();
    if (!stk.empty()) cout&lt;&lt;stk.top();
    else cout&lt;&lt;-1;
    cout&lt;&lt;&#39; &#39;;
    stk.push(x);
}
// 数组
for (int i = 0; i &lt; n; i ++ ) {
  cin&gt;&gt;x;
  while (tt &amp;&amp; stk[tt] &gt;= x) tt --;
  if (tt) cout&lt;&lt;stk[tt];
  else cout&lt;&lt;-1;
  cout&lt;&lt;&#39; &#39;;
  stk[++tt] = x;
}</code></pre>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h3><p>思路：先暴力 再优化，根据单调性，去除不必要的数据和遍历</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_c426d80b7d-IMG_802D4A12F0EB-1.jpeg" alt="IMG_802D4A12F0EB-1.jpeg"> </p>
<pre><code class="C++">// 数组模拟队列
int hh = 0, tt = -1;
for (int i = 0; i &lt; n; i ++ ) {
  while (hh &lt;= tt &amp;&amp; q[hh] &lt; i-k+1) hh++;
  while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;

    q[++tt] = i;
    if (i &gt;= k-1) cout&lt;&lt;a[q[hh]]&lt;&lt;&#39; &#39;;
}
// 双端队列
deque&lt;int&gt; que;
for (int i = 0; i &lt; n; i ++ ) {
  while (!que.empty() &amp;&amp; que.front() &lt; i-k+1) que.pop_front(); // 超出窗口大小出队
  // 次新的不如新的小 丢弃
  while (!que.empty() &amp;&amp; a[i] &lt;= a[que.back()]) que.pop_back();

  que.push_back(i);
  if (i &gt;= k-1) cout&lt;&lt;a[que.front()]&lt;&lt;&#39; &#39;;
}
// 优先队列
priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; que1;
for (int i = 0; i &lt; n; i ++ ) {
    while (!que1.empty() &amp;&amp; que1.top().y &lt; i-k+1) que1.pop();

  que1.push({a[i], i});
  if (que1.size() &gt; k-1) cout&lt;&lt;que1.top().x&lt;&lt;&#39; &#39;;
}</code></pre>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>应用：找子串</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_64cbfa007e-IMG_E8CB8965BF92-1.jpeg" alt="IMG_E8CB8965BF92-1.jpeg"> </p>
<pre><code class="C++">// 求next
for (int i = 2, j = 0; i &lt;= n; i ++ ) {
    while (j &amp;&amp; p[i] != p[j+1]) j = ne[j];
  if (p[i] == p[j+1]) j++;
  ne[i] = j;
}

for (int i = 1, j = 0; i &lt;= m; i ++ ) {
    while (j &amp;&amp; s[i] != p[j+1]) { // 不能匹配或j无处可退
      j = ne[j];
  }
  if (s[i] == p[j+1]) j++;
  if (j == n) {
        // 匹配成功
    cout&lt;&lt;i-n&lt;&lt;&#39; &#39;;
    j = ne[j]; // 
  }
}</code></pre>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>高效存储查找字符串集合</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_8b858dd97e-IMG_F19C60B06C11-1.jpeg" alt="IMG_F19C60B06C11-1.jpeg"> </p>
<pre><code class="C++">// son每个结点的子节点
// cnt以当前点结尾的单词的数量
// 下标为0的点 空节点或者根节点
int son[N][26], cnt[N], idx; 
void insert(char str[]) {
    int p = 0;
    for (int i = 0; str[i] ;i++ ) {
        int u = str[i] - &#39;a&#39;;
        if (!son[p][u]) son[p][u] = ++idx; // 不存在字母u
        p = son[p][u];
    }
    cnt[p] ++;
}
int query(char str[]) { // 返回string出现的次数
    int p = 0;
    for (int i = 0; str[i] ;i++ ) {
        int u = str[i] - &#39;a&#39;;
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}</code></pre>
<h2 id="并查集-Union-Find-Set"><a href="#并查集-Union-Find-Set" class="headerlink" title="并查集 Union Find Set"></a>并查集 Union Find Set</h2><p>合并两个集合、询问两个元素是否在一个集合中</p>
<p>基本：树根（代表元素）的编号是整个树的编号</p>
<p>路径压缩：所有孩子都直接指向根节点</p>
<p>按秩合并：将简单的树合并在复杂的树下（计算深度）</p>
<h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><pre><code class="C++">int p[N]; //储存每个点的祖宗节点

int find(int x) { //返回x的祖宗节点 + 递归保证 路径压缩
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

for (int i = 1; i &lt;= n; i ++ ) p[i] = i; //初始化

p[find(a)] = find(b); //合并a,b两个集合</code></pre>
<h3 id="维护size数组的并查集"><a href="#维护size数组的并查集" class="headerlink" title="维护size数组的并查集"></a>维护size数组的并查集</h3><pre><code class="C++">int p[N], size[N];
//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点
int find(int x){
  if (p[x] != x) p[x] = find(p[x]);
  return p[x];
}
// 初始化，假定节点编号是1~n    
for (int i = 1; i &lt;= n; i ++ ){
  p[i] = i;    
  size[i] = 1;
}
// 合并a和b所在的两个集合：先把size求和    
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
</code></pre>
<h3 id="维护到祖宗节点距离的并查集"><a href="#维护到祖宗节点距离的并查集" class="headerlink" title="维护到祖宗节点距离的并查集"></a>维护到祖宗节点距离的并查集</h3><pre><code class="C++">int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x){
    if (p[x] != x){
        int u = find(p[x]);
        d[x] += d[p[x]];
        p[x] = u;
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i &lt;= n; i ++ ){
    p[i] = i;
    d[i] = 0;
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
</code></pre>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>完全二叉树</p>
<p>根结点小于等于左右子结点</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_52e7bb837f-IMG_06DCF7F7578D-1.jpeg" alt="IMG_06DCF7F7578D-1.jpeg"> </p>
<pre><code class="C++">int h[N]; // 用完全二叉树存堆
// 从根往下调整
void down(int u) {
  int t = u;
  if (u*2 &lt;= size &amp;&amp; h[u*2] &lt; h[t]) t = u*2;
  if (u*2+1 &lt;= size &amp;&amp; h[u*2+1] &lt; h[t]) t = u*@+1;
  if (u != t) {
    swap(h[u], h[t]);
    down(t);
  }
}
void up(); // 向上调整
// 插入
heap[++size] = x; up(size);
// 求最值（堆顶）
head[1]
// 删除最值
heap[1] = heap[size]; size --; down(1);
// 删除任意元素（用最后一个代替原值并执行down或up，这里都写但实际不会都执行下去）
heap[k] = heap[size]; size --; down(k); up(k);
// 修改任意值
heap[k] = x; down(k); up(k);</code></pre>
<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深搜</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广搜</p>
<p>八皇后</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>关键：广搜、入度</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/96221_3f32973686-IMG_99F1477B4A0A-1.jpeg" alt="IMG_99F1477B4A0A-1.jpeg"> </p>
<pre><code class="C++">bool topsort() {
    queue&lt;int&gt; que;
    for (int i = 1; i &lt;= n; i++) // 初始化 将入度为0的点入队
        if (d[i] == 0) que.push(i);

    while(!que.empty()) {
        int tmp = que.front();
        ans.push_back(tmp);
        que.pop();

        for (auto e : edge[tmp]) {
            d[e] --;
            if (d[e] == 0) que.push(e);
        }
    }
    return ans.size() == n; // 全进入ans则存在拓扑
}</code></pre>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>n为点数，m为边数</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/IMG_275108A5538C-1.jpeg" alt="IMG_275108A5538C-1"></p>
<h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><p>稠密图用邻接矩阵</p>
<p>重边保留短边，忽略自环</p>
<p><img src="https://cdn.jsdelivr.net/gh/liting1024/PicImage/PicgoGithub/IMG_E4D127BD4E5A-1.jpeg" alt="IMG_E4D127BD4E5A-1"></p>
<pre><code class="C++">int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra() {
    memset(dist, 0x3f, sizeof dist); //初始化 dist 为无穷
    dist[1] = 0;
    for (int i = 0; i &lt; n - 1; i++) {
        int t = -1;     // 在还未确定最短路的点中，找距离最小的点
        for (int j = 1; j &lt;= n; j++)
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;
        // 用t更新其他点的距离
        for (int j = 1; j &lt;= n; j++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        st[t] = true;
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}</code></pre>
<h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><p>稀疏图用邻接表</p>
<pre><code class="C++">const int N = 510; // 太大会爆vector
typedef pair&lt;int,int&gt; PII;
int n, m, dist[N], weight[N][N];
memset(weight, 0x3f, sizeof weight);
vector&lt;int&gt; g[N];
bool st[N]; 
int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;&gt;&gt; heap; // 小顶堆
    heap.push({0,1}); // first-&gt;距离 second-&gt;点 用距离排序
    while (!heap.empty()) {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;
        if (st[ver]) continue;
        st[ver] = true
        for (auto vec : g[ver]) {
            if (dist[vec] &gt; distance + weight[ver][vec]) {
                dist[vec] = distance + weight[ver][vec];
                heap.push({dist[vec], vec});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}</code></pre>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><pre><code class="C++"></code></pre>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="质（素）数"><a href="#质（素）数" class="headerlink" title="质（素）数"></a>质（素）数</h3><p>大于等于2的整数中，只包含1和本身这两个约数</p>
<p>质数判断一试除法：</p>
<pre><code class="C++">bool is_prime(int n) {
    if (n &lt; 2) return false;
    for (int i = 2; i &lt;= n/i; i++) 
        if (n % i == 0)
        return false;
  return true;
}</code></pre>
<p>质数判断二分解质因数：</p>
<p>从小到大枚举n的所有因数</p>
<pre><code class="C++"></code></pre>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2021/05/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0Review%E3%80%90%E4%B8%80%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E3%80%81Softmax%E3%80%81%E6%84%9F%E7%9F%A5%E6%9C%BA%E3%80%81%E5%8D%B7%E7%A7%AF/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          深度学习Review【一】线性回归、Softmax、感知机、卷积
        
      </div>
    </a>
  
  
    <a href="/2021/01/25/Mac%E4%BD%BF%E7%94%A8SecureCRT%E6%88%96%E7%BB%88%E7%AB%AF%E7%9B%B4%E6%8E%A5%E8%BF%9E%E6%8E%A5%E8%B7%B3%E6%9D%BF%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">Mac使用SecureCRT或终端直接连接跳板机访问内网</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=基础算法 - Li Ting&url=https%3A%2F%2Fliting1024.github.io%2F2021%2F05%2F27%2F%25E5%259F%25BA%25E7%25A1%2580%25E7%25AE%2597%25E6%25B3%2595%2F">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=基础算法 - Li Ting&url=https://liting1024.github.io/2021/05/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a>
    </section>

</article>








<section class="comments">
    <div id="gitalk-container"></div>
</section>









<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/08/05/VisTransformer/">VisTransformer</a>
          </li>
        
          <li>
            <a href="/2022/07/10/Bert/">Bert</a>
          </li>
        
          <li>
            <a href="/2022/07/09/GCN/">GCN</a>
          </li>
        
          <li>
            <a href="/2022/07/09/ResNet/">ResNet</a>
          </li>
        
          <li>
            <a href="/2022/07/01/%E5%86%99%E4%BD%9C%E7%9A%84%E8%89%BA%E6%9C%AF/">研究写作的艺术</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACM/" rel="tag">ACM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E8%AE%BA%E6%96%87/" rel="tag">读论文</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Debug/">Debug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">应用开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Li Ting &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>


<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>





<script src="/dist/build.js?1651727875408.js"></script>


<script src="/dist/custom.js?1651727875408.js"></script>



<!-- 百度链接提交 -->
<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>











</body>

</html>